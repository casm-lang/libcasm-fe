//
//  Copyright (C) 2014-2020 CASM Organization <https://casm-lang.org>
//  All rights reserved.
//
//  Developed by: Philipp Paulweber
//                Emmanuel Pescosta
//                Florian Hahn
//                Ioan Molnar
//                <https://github.com/casm-lang/libcasm-fe>
//
//  This file is part of libcasm-fe.
//
//  libcasm-fe is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  libcasm-fe is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with libcasm-fe. If not, see <http://www.gnu.org/licenses/>.
//
//  Additional permission under GNU GPL version 3 section 7
//
//  libcasm-fe is distributed under the terms of the GNU General Public License
//  with the following clarification and special exception: Linking libcasm-fe
//  statically or dynamically with other modules is making a combined work
//  based on libcasm-fe. Thus, the terms and conditions of the GNU General
//  Public License cover the whole combination. As a special exception,
//  the copyright holders of libcasm-fe give you permission to link libcasm-fe
//  with independent modules to produce an executable, regardless of the
//  license terms of these independent modules, and to copy and distribute
//  the resulting executable under terms of your choice, provided that you
//  also meet, for each linked independent module, the terms and conditions
//  of the license of that module. An independent module is a module which
//  is not derived from or based on libcasm-fe. If you modify libcasm-fe, you
//  may extend this exception to your version of the library, but you are
//  not obliged to do so. If you do not wish to do so, delete this exception
//  statement from your version.
//

CASM

//
//
// Domain Definitions
//

[ export ]
domain Void

[ export ]
domain Agent

[ export ]
domain Object

[ export ]
domain enumeration

[ export ]
domain Boolean

[ export ]
domain Integer

[ export ]
domain Rational

[ export ]
domain String

[ export ]
domain Decimal

[ export ]
template< Size >
domain Binary'Size

[ export ]
template< Signature >
domain RuleRef< Signature >

[ export ]
template< Signature >
domain FuncRef< Signature >

[ export ]
template< Type >
domain Tuple< Type >

[ export ]
template< Type >
domain Record< Type >

[ export ]
template< Type >
domain Range< Type >

[ export ]
template< Type >
domain List< Type >

// [ export ]
// template< Type >
// domain Set< Type >

[ export ]
template< Type >
domain Port< Type >

[ export ]
template< Type >
domain File< Type >

//
//
// Builtin Definitions
//

[ export ]
builtin SelfInstruction< -> Agent >

[ export ]
builtin AbortInstruction< -> Void >

[ export ]
builtin AssertInstruction< Boolean -> Void >

[ export ]
builtin AssureInstruction< Boolean -> Void >

[ export ]
builtin PrintInstruction< String -> Void >

[ export ]
[ pure ]
builtin NotInstruction< Boolean -> Boolean >

[ export ]
[ pure ]
builtin OrInstruction< Boolean * Boolean -> Boolean >

[ export ]
[ pure ]
builtin AddInstruction< Integer * Integer -> Integer >

[ export ]
[ pure ]
builtin SubInstruction< Integer * Integer -> Integer >

[ export ]
[ pure ]
builtin MulInstruction< Integer * Integer -> Integer >

[ export ]
[ pure ]
builtin DivInstruction< Integer * Integer -> Integer >

[ export ]
[ pure ]
builtin ModInstruction< Integer * Integer -> Integer >

[ export ]
[ pure ]
builtin PowInstruction< Integer * Integer -> Integer >

[ export ]
[ pure ]
builtin ConcatInstruction< String * String -> String >

[ export ]
[ pure ]
template< Type >
builtin SizeInstruction< Type -> Integer >

[ export ]
[ pure ]
template< Type >
builtin SymInstruction< Type -> Boolean >

[ export ]
[ pure ]
template< Type >
builtin EquInstruction< Type * Type -> Boolean >

[ export ]
[ pure ]
template< Type >
builtin LthInstruction< Type * Type -> Boolean >

[ export ]
[ pure ]
template< Type >
builtin GthInstruction< Type * Type -> Boolean >

[ export ]
[ pure ]
template< Type >
builtin StrInstruction< Type -> String >

// [ export ]
// [ pure ]
// template< Type, Size >
// builtin AsBinaryInstruction< Type -> Binary'Size >

[ export ]
[ pure ]
template< Type >
builtin BinInstruction< Type -> String >

[ export ]
[ pure ]
template< Type >
builtin OctInstruction< Type -> String >

[ export ]
[ pure ]
template< Type >
builtin HexInstruction< Type -> String >

[ export ]
[ pure ]
template< SequenceType, ElementType >
builtin NthInstruction< SequenceType * Integer -> ElementType >

//
//
// Unary Operator Behaviors
//

/**
    Operator '+'
*/

[ export ]
behavior Positive = {
    [ pure ]
    derived sign : Object -> Object
}

/**
    Operator '-'
*/

[ export ]
behavior Inversion = {
    [ pure ]
    derived invert : Object -> Object
}

/**
    Operator 'not'
*/

[ export ]
behavior Negation = {
    [ pure ]
    derived negate : Object -> Object
}

//
//
// Binary Operator Behaviors
//

/**
    Operator '+'
*/

[ export ]
behavior Addition = {
    [ pure ]
    derived add : Object * Object -> Object
}

/**
    Operator '-'
*/

[ export ]
behavior Subtraction = {
    [ pure ]
    derived subtract : Object * Object -> Object
}

/**
    Operator '*'
*/

[ export ]
behavior Multiplication  = {
    [ pure ]
    derived multiply : Object * Object -> Object
}

/**
    Operator '/'
*/

[ export ]
behavior Division = {
    [ pure ]
    derived divide : Object * Object -> Object
}

/**
    Operator '%'
*/

[ export ]
behavior Modulus = {
    [ pure ]
    derived modulo : Object * Object -> Object
}

/**
    Operator '^'
*/

[ export ]
behavior Exponentiation = {
    [ pure ]
    derived power : Object * Object -> Object
}

/**
    Operator '=' and '!='
*/

[ export ]
behavior Equality = {
    [ pure ]
    derived equal : Object * Object -> Boolean

    [ pure ]
    derived unequal : Object * Object -> Boolean
// @ppaulweber: enable default implementation support
//    derived unequal( this, other : Equality ) -> Boolean =
//        not this.equal( other )
}

/**
    Operator '<' and '>'
*/

[ export ]
behavior PartialOrder = {
    [ pure ]
    derived less : Equality * Equality -> Boolean

    [ pure ]
    derived greater : Equality * Equality -> Boolean
}

/**
    Operator '<=' and '>='
*/

[ export ]
behavior TotalOrder = {
    [ pure ]
    derived lessOrEqual : PartialOrder * PartialOrder -> Boolean

    [ pure ]
    derived greaterOrEqual : PartialOrder * PartialOrder -> Boolean
}

/**
    Operator 'or', 'xor', 'and', and '->' ('implies')
*/

[ export ]
behavior Logical = {
    [ pure ]
    derived or_ : Object * Object -> Boolean

    [ pure ]
    derived xor_ : Object * Object -> Boolean

    [ pure ]
    derived and_ : Object * Object -> Boolean

    [ pure ]
    derived implies_ : Object * Object -> Boolean
}

/**
    Operator 'as' (type casting expression ::= <expr> 'as' <type>)
*/

[ export ]
template< Domain >
behavior TypeCasting< Domain > = {
    [ pure ]
    derived to : Object -> Domain
}

/**
    Operator 'at' (literal call expression ::= <expr> 'at' <literal>)
*/

[ export ]
template< Element >
behavior ElementAccess< Element > = {
    [ pure ]
    derived at : Object * Integer -> Element
}

template< Type >
implement TypeCasting< String > for Tuple< Type > = {
    [ pure ]
    derived convertTo( this ) -> String =
        template< Type : Tuple< Type > > StrInstruction( this )
}

template< Type >
implement ElementAccess< Boolean > for Tuple< Type > = {
    [ pure ]
    derived at( this, position : Integer ) -> Boolean =
        template< SequenceType : Tuple< Type >, ElementType : Boolean >
	    NthInstruction( this, position )
}

template< Type >
implement ElementAccess< Integer > for Tuple< Type > = {
    [ pure ]
    derived at( this, position : Integer ) -> Integer =
        template< SequenceType : Tuple< Type >, ElementType : Integer >
	    NthInstruction( this, position )
}

template< Type >
implement ElementAccess< String > for Tuple< Type > = {
    [ pure ]
    derived at( this, position : Integer ) -> String =
        template< SequenceType : Tuple< Type >, ElementType : String >
	    NthInstruction( this, position )
}

template< Type >
implement ElementAccess< Agent > for Tuple< Type > = {
    [ pure ]
    derived at( this, position : Integer ) -> Agent =
        template< SequenceType : Tuple< Type >, ElementType : Agent >
	    NthInstruction( this, position )
}

template< Type >
implement ElementAccess< enumeration > for Tuple< Type > = {
    [ pure ]
    derived at( this, position : Integer ) -> enumeration =
        template< SequenceType : Tuple< Type >, ElementType : enumeration >
	    NthInstruction( this, position )
}


/**
    Operator '||' (cardinality expression ::= '|' <expr> '|')
*/

[ export ]
behavior Cardinality = {
    [ pure ]
    derived size : Object -> Integer
}

/**
    Symbolic facility
*/

[ export ]
behavior Symbolic = {
    [ pure ]
    derived isSymbolic : Object -> Boolean
}

/**
    Stringify facility
*/

[ export ]
behavior Stringify = {
    [ pure ]
    derived bin : Object -> String

    [ pure ]
    derived oct : Object -> String

    [ pure ]
    derived dec : Object -> String

    [ pure ]
    derived hex : Object -> String
}

/**
    Boolean
*/

implement Symbolic for Boolean = {
    [ pure ]
    derived isSymbolic( this ) -> Boolean =
        template< Type : Boolean > SymInstruction( this )
}

implement Negation for Boolean = {
    [ pure ]
    derived negate( this ) -> Boolean =
        NotInstruction( this )
}

implement Logical for Boolean = {
    [ pure ]
    derived or_( this, other : Boolean ) -> Boolean =
        OrInstruction( this, other )

    [ pure ]
    derived xor_( this, other : Boolean ) -> Boolean =
	 ( this and ( not other ) ) or ( ( not this ) and other )

    [ pure ]
    derived and_( this, other : Boolean ) -> Boolean =
	not ( not this or not other )

    [ pure ]
    derived implies_( this, other : Boolean ) -> Boolean =
	( not this ) or other
}

implement Equality for Boolean = {
    [ pure ]
    derived equal( this, other : Boolean ) -> Boolean =
        template< Type : Boolean > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : Boolean ) -> Boolean =
        not template< Type : Boolean > EquInstruction( this, other )
}

implement TypeCasting< String > for Boolean = {
    [ pure ]
    derived convertTo( this ) -> String =
        if this = undef then
	    "undef"
	else if this then
	    "true"
	else
	    "false"
}

implement TypeCasting< Boolean > for Boolean = {
    [ pure ]
    derived convertTo( this ) -> Boolean =
        this
}

implement TypeCasting< Integer > for Boolean = {
    [ pure ]
    derived convertTo( this ) -> Integer =
        if this = undef then
	    undef
	else if this then
	    1
	else
	    0
}

/**
    Agent
*/

implement TypeCasting< String > for Agent = {
    [ pure ]
    derived convertTo( this ) -> String =
        template< Type : Agent > StrInstruction( this )
}

/**
    Integer
*/

implement Integer = {
    derived funky -> String = "foobarbaz"
}

implement Symbolic for Integer = {
    [ pure ]
    derived isSymbolic( this ) -> Boolean =
        template< Type : Integer > SymInstruction( this )
}

implement Positive for Integer = {
    [ pure ]
    derived sign( this ) -> Integer = this
}

implement Inversion for Integer = {
    [ pure ]
    derived invert( this ) -> Integer = 0 - this
}

implement Addition for Integer = {
    [ pure ]
    derived add( this, other : Integer ) -> Integer =
        AddInstruction( this, other )
}

implement Subtraction for Integer = {
    [ pure ]
    derived subtract( this, other : Integer ) -> Integer =
        SubInstruction( this, other )
}

implement Multiplication for Integer  = {
    [ pure ]
    derived multiply( this, other : Integer ) -> Integer =
        MulInstruction( this, other )
}

implement Division for Integer = {
    [ pure ]
    derived divide( this, other : Integer ) -> Integer =
        DivInstruction( this, other )
}

implement Modulus for Integer = {
    [ pure ]
    derived modulo( this, other : Integer ) -> Integer =
        ModInstruction( this, other )
}

implement Exponentiation for Integer = {
    [ pure ]
    derived power( this, other : Integer ) -> Integer =
        PowInstruction( this, other )
}

implement Equality for Integer = {
    [ pure ]
    derived equal( this, other : Integer ) -> Boolean =
        template< Type : Integer > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : Integer ) -> Boolean =
        not template< Type : Integer > EquInstruction( this, other )
}

implement PartialOrder for Integer = {
    [ pure ]
    derived lessThan( this, other : Integer ) -> Boolean =
        template< Type : Integer > LthInstruction( this, other )

    [ pure ]
    derived greaterThan( this, other : Integer) -> Boolean =
        template< Type : Integer > GthInstruction( this, other )
}

implement TotalOrder for Integer = {
    [ pure ]
    derived lessThanOrEqual( this, other : Integer ) -> Boolean =
        (this < other) or (this = other)

    [ pure ]
    derived greaterThanOrEqual( this, other : Integer) -> Boolean =
        (this > other) or (this = other)
}

implement TypeCasting< String > for Integer = {
    [ pure ]
    derived convertTo( this ) -> String =
        template< Type : Integer > StrInstruction( this )
}

implement TypeCasting< Boolean > for Integer = {
    [ pure ]
    derived convertTo( this ) -> Boolean =
        if this = undef then
	    undef
	else if this != 0 then
	    true
	else
	    false
}

implement TypeCasting< Integer > for Integer = {
    [ pure ]
    derived convertTo( this ) -> Integer =
        this
}

// TODO: FIXME: @ppaulweber
// template< N : Integer >
// implement TypeCasting< Binary'N > for Integer = {
//     [ pure ]
//     derived toBinary( this ) -> Binary =
//         AsBinaryInstruction( this )
// }

implement Cardinality for Integer = {
    [ pure ]
    derived size( this ) -> Integer = 1
}

implement Stringify for Integer = {
    [ pure ]
    derived bin( this ) -> String =
        template< Type : Integer > BinInstruction( this )

    [ pure ]
    derived oct( this ) -> String =
        template< Type : Integer > OctInstruction( this )

    [ pure ]
    derived dec( this ) -> String =
        this as String

    [ pure ]
    derived hex( this ) -> String =
        template< Type : Integer > HexInstruction( this )
}

/**
    Rational
*/

implement Symbolic for Rational = {
    [ pure ]
    derived isSymbolic( this ) -> Boolean =
        template< Type : Rational > SymInstruction( this )
}

implement Positive for Rational = {
    [ pure ]
    derived sign( this ) -> Rational = this
}

// implement Inversion for Rational = {
//     [ pure ]
//     derived invert( this ) -> Rational = 0r0/1 - this
// }

// implement Addition for Rational = {
//     [ pure ]
//     derived add( this, other : Rational ) -> Rational =
//         TODO
// }

// implement Subtraction for Rational = {
//     [ pure ]
//     derived subtract( this, other : Rational ) -> Rational =
//         TODO
// }

// implement Multiplication for Rational  = {
//     [ pure ]
//     derived multiply( this, other : Rational ) -> Rational =
//         TODO
// }

// implement Division for Rational = {
//     [ pure ]
//     derived divide( this, other : Rational ) -> Rational =
//         TODO
// }

// implement Modulus for Rational = {
//     [ pure ]
//     derived modulo( this, other : Rational ) -> Rational =
//         TODO
// }

// implement Exponentiation for Rational = {
//     [ pure ]
//     derived power( this, other : Rational ) -> Rational =
//         TODO
// }

implement Equality for Rational = {
    [ pure ]
    derived equal( this, other : Rational ) -> Boolean =
        template< Type : Rational > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : Rational ) -> Boolean =
        not template< Type : Rational > EquInstruction( this, other )
}

implement PartialOrder for Rational = {
    [ pure ]
    derived lessThan( this, other : Rational ) -> Boolean =
        template< Type : Rational > LthInstruction( this, other )

    [ pure ]
    derived greaterThan( this, other : Rational ) -> Boolean =
        template< Type : Rational > GthInstruction( this, other )
}

implement TotalOrder for Rational = {
    [ pure ]
    derived lessThanOrEqual( this, other : Rational ) -> Boolean =
        (this < other) or (this = other)

    [ pure ]
    derived greaterThanOrEqual( this, other : Rational ) -> Boolean =
        (this > other) or (this = other)
}

implement TypeCasting< String > for Rational = {
    [ pure ]
    derived convertTo( this ) -> String =
        template< Type : Rational > StrInstruction( this )
}

implement Cardinality for Rational = {
    [ pure ]
    derived size( this ) -> Integer = 1
}

/**
    String
*/

implement Symbolic for String = {
    [ pure ]
    derived isSymbolic( this ) -> Boolean =
        template< Type : String > SymInstruction( this )
}

implement Addition for String = {
    [ pure ]
    derived add( this, other : String ) -> String =
        ConcatInstruction( this, other )
}

implement Equality for String = {
    [ pure ]
    derived equal( this, other : String ) -> Boolean =
        template< Type : String > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : String ) -> Boolean =
        not template< Type : String > EquInstruction( this, other )
}

implement TypeCasting< String > for String = {
    [ pure ]
    derived convertTo( this ) -> String = this
}

/**
    enumeration behaviors for all definitions
*/

implement Symbolic for enumeration = {
    [ pure ]
    derived isSymbolic( this ) -> Boolean =
        template< Type : enumeration > SymInstruction( this )
}

implement Equality for enumeration = {
    [ pure ]
    derived equal( this, other : enumeration ) -> Boolean =
        template< Type : enumeration > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : enumeration ) -> Boolean =
        not template< Type : enumeration > EquInstruction( this, other )
}

implement Cardinality for enumeration = {
    [ pure ]
    derived size( this ) -> Integer =
        template< Type : enumeration > SizeInstruction( this )
}

implement TypeCasting< String > for enumeration = {
    [ pure ]
    derived convertTo( this ) -> String =
        template< Type : enumeration > StrInstruction( this )
}

implement TypeCasting< enumeration > for enumeration = {
    [ pure ]
    derived convertTo( this ) -> enumeration =
        this
}

// /**
//     Binary behaviors for all definitions
// */

// template< N : Integer >
// implement Symbolic for Binary'N = {
//     [ pure ]
//     derived isSymbolic( this ) -> Boolean =
//         SymInstruction( this )
// }

// template< N : Integer >
// implement Equality for Binary'N = {
//     [ pure ]
//     derived equal( this, other : Binary'N ) -> Boolean =
//         template< Type : Binary'N > EquInstruction( this, other )

//     [ pure ]
//     derived unequal( this, other : Binary'N ) -> Boolean =
//         not template< Type : Binary'N > EquInstruction( this, other )
// }

// template< N : Integer >
// implement Cardinality for Binary'N = {
//     [ pure ]
//     derived size( this ) -> Integer =
//         SizeInstruction( this )
// }

// template< N : Integer >
// implement TypeCasting< String > for Binary'N = {
//     [ pure ]
//     derived convertTo( this ) -> String =
//         StrInstruction( this )
// }

//
//
// RuleRef behaviors for all type domains ('RuleRef' '<' <type-relation> '>')
//

template< Signature >
implement Equality for RuleRef< Signature > = {
    [ pure ]
    derived equal( this, other : RuleRef< Signature > ) -> Boolean =
        template< Type : RuleRef< Signature > > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : RuleRef< Signature > ) -> Boolean =
        not template< Type : RuleRef< Signature > > EquInstruction( this, other )
}

template< Signature >
implement TypeCasting< String > for RuleRef< Signature > = {
    [ pure ]
    derived convertTo( this ) -> String =
        template< Type : RuleRef< Signature > > StrInstruction( this )
}

//
//
// FuncRef behaviors for all type domains ('FuncRef' '<' <type-relation> '>')
//

template< Signature >
implement Equality for FuncRef< Signature > = {
    [ pure ]
    derived equal( this, other : FuncRef< Signature > ) -> Boolean =
        template< Type : FuncRef< Signature > > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : FuncRef< Signature > ) -> Boolean =
        not template< Type : FuncRef< Signature > > EquInstruction( this, other )
}

template< Signature >
implement TypeCasting< String > for FuncRef< Signature > = {
    [ pure ]
    derived convertTo( this ) -> String =
        template< Type : FuncRef< Signature > > StrInstruction( this )
}

//
//
// Range< Type >
//

template< Type >
implement Cardinality for Range< Type > = {
    [ pure ]
    derived size( this ) -> Integer =
        template< Type : Range< Type > > SizeInstruction( this )
}

//
//
// Agent
//

implement Equality for Agent = {
    [ pure ]
    derived equal( this, other : Agent ) -> Boolean =
        template< Type : Agent > EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : Agent ) -> Boolean =
        not template< Type : Agent > EquInstruction( this, other )
}

//
//
// Prelude Specification
//

[ export ]
function program : Agent -> RuleRef< -> Void >

[ export ]
derived self -> Agent =
    SelfInstruction

[ export ]
rule abort =
    AbortInstruction

[ export ]
rule assert( value : Boolean ) =
    AssertInstruction( value )

[ export ]
rule assure( value : Boolean ) =
    AssureInstruction( value )

[ export ]
rule print( text : String ) =
    PrintInstruction( text )

[ export ]
rule println( text : String ) =
    print( text + "\n" )

//
//
// Greeting Specification
//

//using Agent = Integer init { (123) -> @greeting }
//init { (123) -> @greeting } using Agent = Integer
init greeting

function x : -> ( String, Integer ) = { ( "asdf", 123 ) }

function a : -> Integer = { 0 }

// function c : -> Integer'[1..10]

// derived b( x : Integer'[-5..5] ) -> Integer = x*10

enumeration Lala = { Foo, Bar, Baz, Qux }

rule greeting = {
    if self = self then skip

    print( "Hello World!\n" )

    println( "x.1 = " + x.1 )

    println( "x.2 = " + x.2 as String )

    assert( x.1 = "asdf" )
    assert( x.2 = 123 )

    assert( a.isSymbolic.isSymbolic = false )

    let y : Integer = undef in
        assert( y.add( 20 ) = undef )

    //let x = undef in skip
}
