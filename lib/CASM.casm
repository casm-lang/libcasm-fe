//
//  Copyright (C) 2014-2019 CASM Organization <https://casm-lang.org>
//  All rights reserved.
//
//  Developed by: Philipp Paulweber
//                Emmanuel Pescosta
//                Florian Hahn
//                Ioan Molnar
//                <https://github.com/casm-lang/libcasm-fe>
//
//  This file is part of libcasm-fe.
//
//  libcasm-fe is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  libcasm-fe is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with libcasm-fe. If not, see <http://www.gnu.org/licenses/>.
//
//  Additional permission under GNU GPL version 3 section 7
//
//  libcasm-fe is distributed under the terms of the GNU General Public License
//  with the following clarification and special exception: Linking libcasm-fe
//  statically or dynamically with other modules is making a combined work
//  based on libcasm-fe. Thus, the terms and conditions of the GNU General
//  Public License cover the whole combination. As a special exception,
//  the copyright holders of libcasm-fe give you permission to link libcasm-fe
//  with independent modules to produce an executable, regardless of the
//  license terms of these independent modules, and to copy and distribute
//  the resulting executable under terms of your choice, provided that you
//  also meet, for each linked independent module, the terms and conditions
//  of the license of that module. An independent module is a module which
//  is not derived from or based on libcasm-fe. If you modify libcasm-fe, you
//  may extend this exception to your version of the library, but you are
//  not obliged to do so. If you do not wish to do so, delete this exception
//  statement from your version.
//

CASM

[ export ]
rule print( text : String ) =
    IR::PrintInstruction( text )

[ export ]
rule println( text : String ) =
    print( text + "\n" )

[ export ]
rule assert( value : Boolean ) =
    IR::AssertInstruction( value )


/**
    Operator '+' (unary)
*/

[ export ]
feature Positive = {
    [ pure ]
    derived sign : Object -> Object
}

/**
    Operator '-' (unary)
*/

[ export ]
feature Inversion = {
    [ pure ]
    derived invert : Object -> Object
}

/**
    Operator 'not' (unary)
*/

[ export ]
feature Negation = {
    [ pure ]
    derived negate : Object -> Object
}

/**
    Operator 'and', 'or', 'xor' (unary)
*/

[ export ]
feature Logical = {
    [ pure ]
    derived or_ : Object * Object -> Boolean

    [ pure ]
    derived xor_ : Object * Object -> Boolean

    [ pure ]
    derived and_ : Object * Object -> Boolean

    [ pure ]
    derived implies_ : Object * Object -> Boolean
}

/**
    Operator '+' (binary)
*/

[ export ]
feature Addition = {
    [ pure ]
    derived add : Object * Object -> Object
}

/**
    Operator '-' (binary)
*/

[ export ]
feature Subtraction = {
    [ pure ]
    derived subtract : Object * Object -> Object
}

/**
    Operator '='
*/

[ export ]
feature Equality = {
    [ pure ]
    derived
    equal : Object * Object -> Boolean

    [ pure ]
    derived unequal : Object * Object -> Boolean
//    derived unequal( this ), other : Equality ) -> Boolean =
//        not this.equal( other )
}

/**
    Operator '<', '>'
*/

[ export ]
feature PartialOrder = {
    [ pure ]
    derived less : Equality * Equality -> Boolean

    [ pure ]
    derived greater : Equality * Equality -> Boolean
}

/**
    Operator '<=', '>='
*/

[ export ]
feature TotalOrder = {
    [ pure ]
    derived lessOrEqual : PartialOrder * PartialOrder -> Boolean

    [ pure ]
    derived greaterOrEqual : PartialOrder * PartialOrder -> Boolean
}

/**
    Operator 'as'
*/

[ export ]
feature TypeCastingString = {
    [ pure ]
    derived toString : Object -> String
}

/**
    Operator '|' <expr> |'
*/

[ export ]
feature Cardinality = {
    [ pure ]
    derived size : Object -> Integer
}

/**
    Boolean
*/

implement Negation for Boolean = {
    [ pure ]
    derived negate( this ) -> Boolean = IR::NotInstruction( this )
}

implement Logical for Boolean = {
    [ pure ]
    derived or_( this, other : Boolean ) -> Boolean =
        IR::OrInstruction( this, other )

    [ pure ]
    derived xor_( this, other : Boolean ) -> Boolean =
        // IR::XorInstruction( this, other )
	this and (not other)

    [ pure ]
    derived and_( this, other : Boolean ) -> Boolean =
        // IR::AndInstruction( this, other )
	not ( not this or not other )

    [ pure ]
    derived implies_( this, other : Boolean ) -> Boolean =
        IR::ImpInstruction( this, other )
}

implement TypeCastingString for Boolean = {
    [ pure ]
    derived toString( this ) -> String = IR::AsStringInstruction( this )
}

/**
    Integer
*/

implement Positive for Integer = {
    [ pure ]
    derived sign( this ) -> Integer = this
}

implement Inversion for Integer = {
    [ pure ]
    derived invert( this ) -> Integer = 0 - this
}

implement Addition for Integer = {
    [ pure ]
    derived add( this, other : Integer ) -> Integer =
        IR::AddInstruction( this, other )
}

implement Subtraction for Integer = {
    [ pure ]
    derived subtract( this, other : Integer ) -> Integer =
        IR::SubInstruction( this, other )
}

implement Equality for Integer = {
    [ pure ]
    derived equal( this, other : Integer ) -> Boolean =
        IR::EquInstruction( this, other )

    [ pure ]
    derived unequal( this, other : Integer ) -> Boolean =
        not this.equal( other )
}

implement PartialOrder for Integer = {
    [ pure ]
    derived lessThan( this, other : Integer ) -> Boolean =
        IR::LthInstruction( this, other )

    [ pure ]
    derived greaterThan( this, other : Integer) -> Boolean =
        IR::GthInstruction( this, other )
}

implement TotalOrder for Integer = {
    [ pure ]
    derived lessThanOrEqual( this, other : Integer ) -> Boolean =
        (this < other) or (this = other)

    [ pure ]
    derived greaterThanOrEqual( this, other : Integer) -> Boolean =
        (this > other) or (this = other)
}

implement TypeCastingString for Integer = {
    [ pure ]
    derived toString( this ) -> String =
        IR::AsStringInstruction( this )
}

implement Cardinality for Integer = {
    [ pure ]
    derived size( this ) -> Integer = 1
}

/**
    String
*/

implement Addition for String = {
    [ pure ]
    derived add( this, other : String ) -> String =
        IR::ConcatInstruction( this, other )
}

implement TypeCastingString for String = {
    [ pure ]
    derived toString( this ) -> String = this
}

/**
    enumeration features for all definitions
*/

implement Equality for enumeration = {
    [ pure ]
    derived equal( this, other : Object ) -> Boolean =
        IR::EquInstruction( this, other )
}

implement Cardinality for enumeration = {
    [ pure ]
    derived size( this ) -> Integer =
        IR::SizeInstruction( this )
}

implement TypeCastingString for enumeration = {
    [ pure ]
    derived toString( this ) -> String =
        IR::AsStringInstruction( this )
}
